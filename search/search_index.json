{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GLOW2D","text":"<p>This package builds off of the GLobal airglOW model. The GLOW model is evaluated on an altitude grid at a location. For non-zenith observation geometries, the model requires evaluation at multiple points along the line of sight. The <code>glow2d</code> library wraps the <code>ncarglow.no_precipitation()</code> function to generate the output on a 2D grid in a geocentric (GEO) coordinate system and in a local (ZA, R) coordinate system.</p>"},{"location":"#principle","title":"Principle","text":"<p>GLOW model is evaluated at one geolocation (latitude, longitude) at a given time. Assuming spherical geometry, for a given bearing, the GLOW model can be evaluated at different geolocations at a given time in a geocentric coordinate system . The local polar coordinate system, defined at the starting location as (r, \\zeta, \\phi), is related to the geocentric coordinate system through the equations:      r = \\sqrt{(R\\cos{\\theta} - R_0)^2 + R^2\\sin^2{\\theta}}, \\\\     \\zeta = \\arctan{\\frac{R\\sin\\theta}{R\\cos\\theta - R_0}},\\\\     \\phi = \\phi  R_0 is the distance to the origin of the local polar coordinate system from the center of the earth.</p> <p>  Fig. 1: Geometry of observation </p> <p>A volume element in the (R, \\theta, \\phi) coordinate system is related to a volume element in the (r, \\zeta, \\phi) coordinate system through the following equation:      dR d\\theta d\\phi = \\left|J_{Rr}\\right| dr d\\zeta d\\phi,  where \\left|J_{Rr}\\right| is the determinant      \\left|\\begin{array}{cc} \\frac{\\partial r}{\\partial R} &amp; \\frac{\\partial r}{\\partial \\theta} \\\\                         \\frac{\\partial \\zeta}{\\partial R} &amp; \\frac{\\partial \\zeta}{\\partial \\theta} \\end{array}\\right|             = \\frac{R}{r^3}\\left(R^2 + R_0^2 - 2 R R_0 \\cos{\\theta}\\right).  The determinant is evaluated at a position (R, \\theta, \\phi). Note, that the determinant does not depend on \\phi, i.e. the geometry is azimuthally symmetric, and r is known given R, \\theta.</p> <p>GLOW model is executed in the R, \\theta~(,~\\phi) coordinate system on a uniform grid. The non-linearity of the coordinate transformation from R, \\theta~(,~\\phi) to r, \\zeta~(,~\\phi) results in a non-uniform grid in r, \\zeta coordinates for points in R, \\theta coordinates. An interpolation is performed to an uniform grid in r, \\zeta coordinates, followed by a normalization by \\left|J_{Rr}\\right| for density outputs, such as the volume emission rate.</p> <p>The emission reaching a detector of area A, subtending a solid angle d\\zeta d\\phi is, then,      IER(\\zeta) = A \\int_0^\\phi \\int_0^\\infty \\int_{\\zeta - \\delta\\zeta}^{\\zeta + \\delta\\zeta}         \\frac{VER(r, \\zeta)}{4\\pi r^2}r^2 dr d\\zeta d\\phi.  Note, since the volume emission rate is isotropic, the number of photons incident from one point in the sky onto the detector is given by A\\frac{VER(r, \\zeta)}{4\\pi r^2}.</p>"},{"location":"#installation","title":"Installation","text":"<p>Directly using <code>pip</code>: <pre><code>$ pip install glow2d\n</code></pre></p> <p>Indirectly by <code>git clone</code>: <pre><code>$ git clone https://github.com/sunipkm/glow2d &amp;&amp; cd glow2d\n$ pip install .\n</code></pre></p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The following non-trivial dependencies are present:</p> <ul> <li>ncarglow</li> <li>geomagdata</li> <li>geopy</li> <li>haversine</li> <li>xarray</li> </ul> <p>This code uses glowpython package to run the GLOW model. geomagdata is used to get the $F_{10.7}$ and $A_p$ indices from the new data source.</p>"},{"location":"#usage","title":"Usage","text":"<p>For example:</p> <pre><code>from datetime import datetime\nfrom glow2d import glow2d_polar as grc\ntime = datetime(2022, 2, 15, 20, 0, 0).astimezone('UTC') # 20:00 hours local in UTC\nlat, lon = 42.64981361744372, -71.31681056737486 # location of observation\nbearing = 40 # 40 deg northeast, refer to geopy.GreatCircleDistance().destination() for more info.\niono_loc, iono_geo = grc.polar_model(time, lat, lon, bearing, full_output=True) # generate output in local and GEO coordinates\n</code></pre> <p>The <code>iono_loc</code> dataset is:</p> <pre><code>&lt;xarray.Dataset&gt;\nDimensions:     (za: 200, r: 500, wavelength: 15, energy: 100)\nCoordinates:\n* za          (za) float64 1.571 1.563 1.555 1.547 ... 0.01579 0.007893 0.0\n* r           (r) float64 0.0 7.391 14.78 ... 3.673e+03 3.681e+03 3.688e+03\n* wavelength  (wavelength) &lt;U21 '3371' '4278' '5200' ... '1356' '1493' '1304'\n* energy      (energy) float64 0.2 0.8 1.2 1.8 2.2 ... 457.3 480.7 505.4 531.3\nData variables: (12/18)\nTn          (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nO           (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nN2          (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nO2          (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nNO          (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nNeIn        (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\n...          ...\npedersen    (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nhall        (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nTe          (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nTi          (za, r) float64 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nver         (za, r, wavelength) float64 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0\nprecip      (r, energy) float64 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0\nAttributes:\ngeomag_params:                       Ap     Kp   f107 resolution       f1...\ntime:           2022-02-15T11:00:00+00:00\nglatlon:        (42.64981361744372, -71.31681056737486)\n</code></pre> <p>The <code>iono_geo</code> dataset is: <pre><code>&lt;xarray.Dataset&gt;\nDimensions:         (angle: 100, alt_km: 250, wavelength: 15, state: 12,\nenergy: 100)\nCoordinates:\n* alt_km          (alt_km) float64 60.0 60.6 61.2 61.8 ... 953.4 957.9 962.4\n* wavelength      (wavelength) &lt;U21 '3371' '4278' '5200' ... '1493' '1304'\n* state           (state) &lt;U6 'O+(2P)' 'O+(2D)' 'O+(4S)' ... 'O(1S)' 'O(1D)'\n* energy          (energy) float64 0.2 0.8 1.2 1.8 ... 457.3 480.7 505.4 531.3\n* angle           (angle) float64 0.0 0.005323 0.01065 ... 0.5163 0.5217 0.527\nlat             (angle) float64 42.65 42.88 43.12 ... 60.15 60.25 60.34\nlon             (angle) float64 -71.32 -71.05 -70.78 ... -31.7 -31.12 -30.53\nData variables: (12/21)\nTn              (angle, alt_km) float64 237.0 236.0 235.0 ... 815.0 815.0\nO               (angle, alt_km) float64 0.0 0.0 0.0 ... 1.2e+03 1.11e+03\nN2              (angle, alt_km) float64 4.49e+15 4.17e+15 ... 0.0102 0.00893\nO2              (angle, alt_km) float64 1.2e+15 1.12e+15 ... 1.9e-05\nNO              (angle, alt_km) float64 7.81e+07 7.81e+07 ... 5.92e-08\nNeIn            (angle, alt_km) float64 100.0 100.0 ... 2.35e+04 2.34e+04\n...              ...\nTi              (angle, alt_km) float64 236.9 235.9 ... 2.715e+03 2.726e+03\nver             (angle, alt_km, wavelength) float64 0.0 0.0 0.0 ... 0.0 0.0\nproduction      (angle, alt_km, state) float64 0.0 nan nan ... 0.0 0.0 0.0\nloss            (angle, alt_km, state) float64 nan nan nan ... 0.0 1.1 0.01\nprecip          (angle, energy) float64 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0\nexcitedDensity  (angle, alt_km, state) float64 nan nan nan ... 0.0 0.0 0.01\n...\nAttributes:\ngeomag_params:                       Ap     Kp   f107 resolution       f1...\ntime:           2022-02-15T11:00:00+00:00\nglatlon:        (42.64981361744372, -71.31681056737486)\n</code></pre></p> <p>All angles are in radians, and distances in km. Due to the nature of the coordinate transformation, local coordinate outputs do not contain any <code>NaN</code> values.</p>"},{"location":"gen_2d/","title":"GLOW 2D Generation in GEO Coordinates","text":""},{"location":"gen_2d/#glow2dgeo_model","title":"<code>glow2d.geo_model</code>","text":"<p>Run GLOW model looking along heading from the current location and return the model output in (T, R) geocentric coordinates where T is angle in radians from the current location along the great circle following current heading, and R is altitude in kilometers. R is in an uniform grid with <code>n_alt</code> points.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>datetime</code> <p>Datetime of GLOW calculation.</p> required <code>lat</code> <code>Numeric</code> <p>Latitude of starting location.</p> required <code>lon</code> <code>Numeric</code> <p>Longitude of starting location.</p> required <code>heading</code> <code>Numeric</code> <p>Heading (look direction).</p> required <code>max_alt</code> <code>Numeric</code> <p>Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.</p> <code>1000</code> <code>n_pts</code> <code>int</code> <p>Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.</p> <code>50</code> <code>n_bins</code> <code>int</code> <p>Number of energy bins. Defaults to 100.</p> <code>100</code> <code>n_alt</code> <code>int</code> <p>Number of altitude bins, must be &gt; 100. Defaults to <code>None</code>, i.e. uses same number of bins as a single GLOW run.</p> <code>None</code> <code>n_threads</code> <code>int</code> <p>Number of threads for parallel GLOW runs. Set to <code>None</code> to use all system threads. Defaults to <code>None</code>.</p> <code>None</code> <code>show_progress</code> <code>bool</code> <p>Use TQDM to show progress of GLOW model calculations. Defaults to <code>True</code>.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Passed to <code>glowpython.generic</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bds</code> <code>xarray.Dataset</code> <p>Ionospheric parameters and brightnesses (with production and loss) in GEO coordinates.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Number of position bins can not be odd.</p> <code>ValueError</code> <p>Number of position bins can not be &lt; 20.</p> <code>ValueError</code> <p>Resampling can not be &lt; 0.5.</p> Warns <p>ResourceWarning: Number of threads requested is more than available system threads.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>def geo_model(time: datetime, lat: Numeric, lon: Numeric, heading: Numeric, max_alt: Numeric = 1000, n_pts: int = 50, n_bins: int = 100, *, n_alt: int = None, n_threads: int = None, show_progress: bool = True, **kwargs) -&gt; xarray.Dataset:\n\"\"\"Run GLOW model looking along heading from the current location and return the model output in\n    (T, R) geocentric coordinates where T is angle in radians from the current location along the great circle\n    following current heading, and R is altitude in kilometers. R is in an uniform grid with `n_alt` points.\n    Args:\n        time (datetime): Datetime of GLOW calculation.\n        lat (Numeric): Latitude of starting location.\n        lon (Numeric): Longitude of starting location.\n        heading (Numeric): Heading (look direction).\n        max_alt (Numeric, optional): Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.\n        n_pts (int, optional): Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.\n        n_bins (int, optional): Number of energy bins. Defaults to 100.\n        n_alt (int, optional): Number of altitude bins, must be &gt; 100. Defaults to `None`, i.e. uses same number of bins as a single GLOW run.\n        n_threads (int, optional): Number of threads for parallel GLOW runs. Set to `None` to use all system threads. Defaults to `None`.\n        show_progress (bool, optional): Use TQDM to show progress of GLOW model calculations. Defaults to `True`.\n        kwargs (dict, optional): Passed to `glowpython.generic`.\n    Returns:\n        bds (xarray.Dataset): Ionospheric parameters and brightnesses (with production and loss) in GEO coordinates.\n    Raises:\n        ValueError: Number of position bins can not be odd.\n        ValueError: Number of position bins can not be &lt; 20.\n        ValueError: Resampling can not be &lt; 0.5.\n    Warns:\n        ResourceWarning: Number of threads requested is more than available system threads.\n    \"\"\"\ngrobj = glow2d_geo(time, lat, lon, heading, max_alt,\nn_pts, n_bins, n_alt=n_alt, uniformize_glow=True, n_threads=n_threads, show_progress=show_progress, **kwargs)\nbds = grobj.run_model()\nreturn bds\n</code></pre> <p>Compute GLOW model on the great circle passing through the origin location along the specified bearing.  The result is presented in a geocentric coordinate system.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>class glow2d_geo:\n\"\"\"Compute GLOW model on the great circle passing through the origin location along the specified bearing. \n    The result is presented in a geocentric coordinate system.\n    \"\"\"\ndef __init__(self, time: datetime, lat: Numeric, lon: Numeric, heading: Numeric, max_alt: Numeric = 1000, n_pts: int = 50, n_bins: int = 100, *, n_alt: int = None, uniformize_glow: bool = True, n_threads: int = None, full_circ: bool = False, show_progress: bool = True, **kwargs):\n\"\"\"Create a GLOWRaycast object.\n        Args:\n            time (datetime): Datetime of GLOW calculation.\n            lat (Numeric): Latitude of starting location.\n            lon (Numeric): Longitude of starting location.\n            heading (Numeric): Heading (look direction).\n            max_alt (Numeric, optional): Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.\n            n_pts (int, optional): Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.\n            n_bins (int, optional): Number of energy bins. Defaults to 100.\n            n_alt (int, optional): Number of altitude bins, must be &gt; 100. Used only when `uniformize_glow` is set to `True` (default). Defaults to `None`, i.e. uses same number of bins as a single GLOW run.\n            uniformize_glow (bool, optional): Interpolate GLOW output to an uniform altitude grid. `n_alt` is ignored if this option is set to `False`. Defaults to `True`.\n            n_threads (int, optional): Number of threads for parallel GLOW runs. Set to `None` to use all system threads. Defaults to `None`.\n            full_circ (bool, optional): For testing only, do not use. Defaults to False.\n            show_progress (bool, optional): Use TQDM to show progress of GLOW model calculations. Defaults to True.\n            kwargs (dict, optional): Passed to `glowpython.generic`.\n        Raises:\n            ValueError: Number of position bins can not be odd.\n            ValueError: Number of position bins can not be &lt; 20.\n            ValueError: Number of altitude bins can not be &lt; 100.\n        Warns:\n            ResourceWarning: Number of threads requested is more than available system threads.\n        \"\"\"\nif n_pts % 2:\nraise ValueError('Number of position bins can not be odd.')\nif n_pts &lt; 20:\nraise ValueError('Number of position bins can not be &lt; 20.')\nif n_threads is None:\nn_threads = N_CPUS\nif n_threads &gt; N_CPUS:\nwarnings.warn('Number of requested threads (%d &gt; %d)' % (n_threads, N_CPUS), ResourceWarning)\nself._uniform_glow = uniformize_glow\nself._pt = Point(lat, lon)  # instrument loc\nself._time = time  # time of calc\nif n_alt is not None and n_alt &lt; 100:\nraise ValueError('Number of altitude bins can not be &lt; 100')\nif n_alt is None:\nn_alt = 100  # default\nmax_d = 6400 * np.pi if full_circ else EARTH_RADIUS * \\\n            np.arccos(EARTH_RADIUS / (EARTH_RADIUS + max_alt)\n)  # find maximum distance where LOS intersects exobase # 6400 * np.pi\n# points on the earth where we need to sample\nself._show_prog = show_progress\nself._kwargs = kwargs\ndistpts = np.linspace(0, max_d, n_pts, endpoint=True)\nself._locs = []\nself._nbins = n_bins  # number of energy bins (for later)\nself._nthr = n_threads  # number of threads (for later)\nfor d in distpts:  # for each distance point\ndest = GreatCircleDistance(\nkilometers=d).destination(self._pt, heading)  # calculate lat, lon of location at that distance along the great circle\nself._locs.append((dest.latitude, dest.longitude))  # store it\nif full_circ:  # for fun, _get_angle() does not wrap around for &gt; 180 deg\nnpt = self._locs[-1]\nfor d in distpts:\ndest = GreatCircleDistance(\nkilometers=d).destination(npt, heading)\nself._locs.append((dest.latitude, dest.longitude))\nself._angs = self._get_angle()  # get the corresponding angles\nif full_circ:  # fill the rest if full circle\nself._angs[len(self._angs) // 2:] = 2*np.pi - \\\n                self._angs[len(self._angs) // 2:]\nself._bds = None\ndef _get_angle(self) -&gt; np.ndarray:  # get haversine angles between two lat, lon coords\nangs = []\nfor pt in self._locs:\nang = haversine(self._locs[0], pt, unit=Unit.RADIANS)\nangs.append(ang)\nreturn np.asarray(angs)\n@staticmethod\ndef _uniformize_glow(iono: xarray.Dataset) -&gt; xarray.Dataset:\nalt_km = iono.alt_km.values\nalt = np.linspace(alt_km.min(), alt_km.max(), len(alt_km))  # change to custom\nunit_keys = [\"Tn\", \"O\", \"N2\", \"O2\", \"NO\", \"NeIn\", \"NeOut\", \"ionrate\",\n\"O+\", \"O2+\", \"NO+\", \"N2D\", \"pedersen\", \"hall\", \"Te\", \"Ti\"]\nstate_keys = ['production', 'loss', 'excitedDensity']\ndata_vars = {}\nfor key in unit_keys:\nout = np.interp(alt, alt_km, iono[key].values)\ndata_vars[key] = (('alt_km'), out)\nbds = xarray.Dataset(data_vars=data_vars, coords={'alt_km': alt})\nver = np.zeros(iono['ver'].shape, dtype=float)\nfor idx in range(len(iono.wavelength)):\nver[:, idx] += np.interp(alt, alt_km, iono['ver'].values[:, idx])\nver = xr.DataArray(\nver,\ncoords={'alt_km': alt, 'wavelength': iono.wavelength.values},\ndims=('alt_km', 'wavelength'),\nname='ver'\n)\ndata_vars = {}\nfor key in state_keys:\nout = np.zeros(iono[key].shape)\ninp = iono[key].values\nfor idx in range(len(iono.state)):\nout[:, idx] += np.interp(alt, alt_km, inp[:, idx])\ndata_vars[key] = (('alt_km', 'state'), out)\nprodloss = xarray.Dataset(data_vars=data_vars,\ncoords={'alt_km': alt, 'state': iono.state.values})\nprecip = iono['precip']\nbds: xarray.Dataset = xr.merge((bds, ver, prodloss, precip))\n_ = list(map(lambda x: bds[x].attrs.update(iono[x].attrs), tuple(bds.data_vars.keys())))\nbds.attrs.update(iono.attrs)\nreturn bds\n# calculate glow model for one location\ndef _calc_glow_single_noprecip(self, index):\nd = self._locs[index]\niono = glow.generic(self._time, d[0], d[1], self._nbins, **self._kwargs)\nif self._uniform_glow:\niono = self._uniformize_glow(iono)\nreturn iono\ndef _calc_glow_noprecip(self) -&gt; xarray.Dataset:  # run glow model calculation\nif self._show_prog:\nself._dss = MAP_FCN(self._calc_glow_single_noprecip, range(\nlen(self._locs)), max_workers=self._nthr)\nelse:\nppool = Pool(self._nthr)\nself._dss = ppool.map(self._calc_glow_single_noprecip, range(\nlen(self._locs)))\n# for dest in tqdm(self._locs):\n#     self._dss.append(glow.no_precipitation(time, dest[0], dest[1], self._nbins))\nbds: xarray.Dataset = xr.concat(\nself._dss, pd.Index(self._angs, name='angle'))\nlatlon = np.asarray(self._locs)\nbds = bds.assign_coords(lat=('angle', latlon[:, 0]))\nbds = bds.assign_coords(lon=('angle', latlon[:, 1]))\nreturn bds\ndef run_model(self) -&gt; xarray.Dataset:\n\"\"\"Run the GLOW model calculation to get the model output in GEO coordinates.\n        Returns:\n            xarray.Dataset: GLOW model output in GEO coordinates.\n        \"\"\"\nif self._bds is not None:\nreturn self._bds\n# calculate the GLOW model for each lat-lon point determined in init()\nbds = self._calc_glow_noprecip()\nunit_desc_dict = {\n'angle': ('radians', 'Angle of location w.r.t. radius vector at origin (starting location)'),\n'lat': ('degree', 'Latitude of locations'),\n'lon': ('degree', 'Longitude of location')\n}\n_ = list(map(lambda x: bds[x].attrs.update(\n{'units': unit_desc_dict[x][0], 'description': unit_desc_dict[x][1]}), unit_desc_dict.keys()))\nself._bds = bds\nreturn self._bds  # return the calculated\n</code></pre>"},{"location":"gen_2d/#glow2d._glow2d.glow2d_geo.__init__","title":"<code>__init__(time, lat, lon, heading, max_alt=1000, n_pts=50, n_bins=100, *, n_alt=None, uniformize_glow=True, n_threads=None, full_circ=False, show_progress=True, **kwargs)</code>","text":"<p>Create a GLOWRaycast object.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>datetime</code> <p>Datetime of GLOW calculation.</p> required <code>lat</code> <code>Numeric</code> <p>Latitude of starting location.</p> required <code>lon</code> <code>Numeric</code> <p>Longitude of starting location.</p> required <code>heading</code> <code>Numeric</code> <p>Heading (look direction).</p> required <code>max_alt</code> <code>Numeric</code> <p>Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.</p> <code>1000</code> <code>n_pts</code> <code>int</code> <p>Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.</p> <code>50</code> <code>n_bins</code> <code>int</code> <p>Number of energy bins. Defaults to 100.</p> <code>100</code> <code>n_alt</code> <code>int</code> <p>Number of altitude bins, must be &gt; 100. Used only when <code>uniformize_glow</code> is set to <code>True</code> (default). Defaults to <code>None</code>, i.e. uses same number of bins as a single GLOW run.</p> <code>None</code> <code>uniformize_glow</code> <code>bool</code> <p>Interpolate GLOW output to an uniform altitude grid. <code>n_alt</code> is ignored if this option is set to <code>False</code>. Defaults to <code>True</code>.</p> <code>True</code> <code>n_threads</code> <code>int</code> <p>Number of threads for parallel GLOW runs. Set to <code>None</code> to use all system threads. Defaults to <code>None</code>.</p> <code>None</code> <code>full_circ</code> <code>bool</code> <p>For testing only, do not use. Defaults to False.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>Use TQDM to show progress of GLOW model calculations. Defaults to True.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Passed to <code>glowpython.generic</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Number of position bins can not be odd.</p> <code>ValueError</code> <p>Number of position bins can not be &lt; 20.</p> <code>ValueError</code> <p>Number of altitude bins can not be &lt; 100.</p> Warns <p>ResourceWarning: Number of threads requested is more than available system threads.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>def __init__(self, time: datetime, lat: Numeric, lon: Numeric, heading: Numeric, max_alt: Numeric = 1000, n_pts: int = 50, n_bins: int = 100, *, n_alt: int = None, uniformize_glow: bool = True, n_threads: int = None, full_circ: bool = False, show_progress: bool = True, **kwargs):\n\"\"\"Create a GLOWRaycast object.\n    Args:\n        time (datetime): Datetime of GLOW calculation.\n        lat (Numeric): Latitude of starting location.\n        lon (Numeric): Longitude of starting location.\n        heading (Numeric): Heading (look direction).\n        max_alt (Numeric, optional): Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.\n        n_pts (int, optional): Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.\n        n_bins (int, optional): Number of energy bins. Defaults to 100.\n        n_alt (int, optional): Number of altitude bins, must be &gt; 100. Used only when `uniformize_glow` is set to `True` (default). Defaults to `None`, i.e. uses same number of bins as a single GLOW run.\n        uniformize_glow (bool, optional): Interpolate GLOW output to an uniform altitude grid. `n_alt` is ignored if this option is set to `False`. Defaults to `True`.\n        n_threads (int, optional): Number of threads for parallel GLOW runs. Set to `None` to use all system threads. Defaults to `None`.\n        full_circ (bool, optional): For testing only, do not use. Defaults to False.\n        show_progress (bool, optional): Use TQDM to show progress of GLOW model calculations. Defaults to True.\n        kwargs (dict, optional): Passed to `glowpython.generic`.\n    Raises:\n        ValueError: Number of position bins can not be odd.\n        ValueError: Number of position bins can not be &lt; 20.\n        ValueError: Number of altitude bins can not be &lt; 100.\n    Warns:\n        ResourceWarning: Number of threads requested is more than available system threads.\n    \"\"\"\nif n_pts % 2:\nraise ValueError('Number of position bins can not be odd.')\nif n_pts &lt; 20:\nraise ValueError('Number of position bins can not be &lt; 20.')\nif n_threads is None:\nn_threads = N_CPUS\nif n_threads &gt; N_CPUS:\nwarnings.warn('Number of requested threads (%d &gt; %d)' % (n_threads, N_CPUS), ResourceWarning)\nself._uniform_glow = uniformize_glow\nself._pt = Point(lat, lon)  # instrument loc\nself._time = time  # time of calc\nif n_alt is not None and n_alt &lt; 100:\nraise ValueError('Number of altitude bins can not be &lt; 100')\nif n_alt is None:\nn_alt = 100  # default\nmax_d = 6400 * np.pi if full_circ else EARTH_RADIUS * \\\n        np.arccos(EARTH_RADIUS / (EARTH_RADIUS + max_alt)\n)  # find maximum distance where LOS intersects exobase # 6400 * np.pi\n# points on the earth where we need to sample\nself._show_prog = show_progress\nself._kwargs = kwargs\ndistpts = np.linspace(0, max_d, n_pts, endpoint=True)\nself._locs = []\nself._nbins = n_bins  # number of energy bins (for later)\nself._nthr = n_threads  # number of threads (for later)\nfor d in distpts:  # for each distance point\ndest = GreatCircleDistance(\nkilometers=d).destination(self._pt, heading)  # calculate lat, lon of location at that distance along the great circle\nself._locs.append((dest.latitude, dest.longitude))  # store it\nif full_circ:  # for fun, _get_angle() does not wrap around for &gt; 180 deg\nnpt = self._locs[-1]\nfor d in distpts:\ndest = GreatCircleDistance(\nkilometers=d).destination(npt, heading)\nself._locs.append((dest.latitude, dest.longitude))\nself._angs = self._get_angle()  # get the corresponding angles\nif full_circ:  # fill the rest if full circle\nself._angs[len(self._angs) // 2:] = 2*np.pi - \\\n            self._angs[len(self._angs) // 2:]\nself._bds = None\n</code></pre>"},{"location":"gen_2d/#glow2d._glow2d.glow2d_geo.run_model","title":"<code>run_model()</code>","text":"<p>Run the GLOW model calculation to get the model output in GEO coordinates.</p> <p>Returns:</p> Type Description <code>xarray.Dataset</code> <p>xarray.Dataset: GLOW model output in GEO coordinates.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>def run_model(self) -&gt; xarray.Dataset:\n\"\"\"Run the GLOW model calculation to get the model output in GEO coordinates.\n    Returns:\n        xarray.Dataset: GLOW model output in GEO coordinates.\n    \"\"\"\nif self._bds is not None:\nreturn self._bds\n# calculate the GLOW model for each lat-lon point determined in init()\nbds = self._calc_glow_noprecip()\nunit_desc_dict = {\n'angle': ('radians', 'Angle of location w.r.t. radius vector at origin (starting location)'),\n'lat': ('degree', 'Latitude of locations'),\n'lon': ('degree', 'Longitude of location')\n}\n_ = list(map(lambda x: bds[x].attrs.update(\n{'units': unit_desc_dict[x][0], 'description': unit_desc_dict[x][1]}), unit_desc_dict.keys()))\nself._bds = bds\nreturn self._bds  # return the calculated\n</code></pre>"},{"location":"overview/","title":"GLOW 2D Local Polar Coordinate Transformation","text":""},{"location":"overview/#glow2dpolar_model","title":"<code>glow2d.polar_model</code>","text":"<p>Run GLOW model looking along heading from the current location and return the model output in (ZA, R) local coordinates where ZA is zenith angle in radians and R is distance in kilometers.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>datetime</code> <p>Datetime of GLOW calculation.</p> required <code>lat</code> <code>Numeric</code> <p>Latitude of starting location.</p> required <code>lon</code> <code>Numeric</code> <p>Longitude of starting location.</p> required <code>heading</code> <code>Numeric</code> <p>Heading (look direction).</p> required <code>altitude</code> <code>Numeric</code> <p>Altitude of local polar coordinate system origin in km above ASL. Must be &lt; 100 km. Defaults to 0.</p> <code>0</code> <code>max_alt</code> <code>Numeric</code> <p>Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.</p> <code>1000</code> <code>n_pts</code> <code>int</code> <p>Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.</p> <code>50</code> <code>n_bins</code> <code>int</code> <p>Number of energy bins. Defaults to 100.</p> <code>100</code> <code>n_alt</code> <code>int</code> <p>Number of altitude bins, must be &gt; 100. Defaults to None, i.e. uses same number of bins as a single GLOW run.</p> <code>None</code> <code>with_prodloss</code> <code>bool</code> <p>Calculate production and loss parameters in local coordinates. Defaults to False.</p> <code>False</code> <code>n_threads</code> <code>int</code> <p>Number of threads for parallel GLOW runs. Set to None to use all system threads. Defaults to None.</p> <code>None</code> <code>full_output</code> <code>bool</code> <p>Returns only local coordinate GLOW output if False, and a tuple of local and GEO outputs if True. Defaults to False.</p> <code>False</code> <code>resamp</code> <code>Numeric</code> <p>Number of R and ZA points in local coordinate output. <code>len(R) = len(alt_km) * resamp</code> and <code>len(ZA) = n_pts * resamp</code>. Must be &gt; 0.5. Defaults to 1.5.</p> <code>1.5</code> <code>show_progress</code> <code>bool</code> <p>Use TQDM to show progress of GLOW model calculations. Defaults to True.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Passed to <code>glowpython.generic</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>iono</code> <code>xarray.Dataset</code> <p>Ionospheric parameters and brightnesses (with or without production and loss) in local coordinates. This is a reference and should not be modified.</p> <code>xarray.Dataset | tuple(xarray.Dataset, xarray.Dataset)</code> <p>iono, bds (xarray.Dataset, xarray.Dataset): These values are returned only if <code>full_output == True</code>. Both are references and should not be modified.</p> <code>xarray.Dataset | tuple(xarray.Dataset, xarray.Dataset)</code> <ul> <li>Ionospheric parameters and brightnesses (with or without production and loss) in local coordinates.</li> </ul> <code>xarray.Dataset | tuple(xarray.Dataset, xarray.Dataset)</code> <ul> <li>Ionospheric parameters and brightnesses (with production and loss) in GEO coordinates.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>Number of position bins can not be odd.</p> <code>ValueError</code> <p>Number of position bins can not be &lt; 20.</p> <code>ValueError</code> <p>n_alt can not be &lt; 100.</p> <code>ValueError</code> <p>Resampling can not be &lt; 0.5.</p> <code>ValueError</code> <p>altitude must be in the range [0, 100].</p> Warns <p>ResourceWarning: Number of threads requested is more than available system threads.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>def polar_model(time: datetime, lat: Numeric, lon: Numeric, heading: Numeric, altitude: Numeric = 0, max_alt: Numeric = 1000, n_pts: int = 50, n_bins: int = 100, *, n_alt: int = None, with_prodloss: bool = False, n_threads: int = None, full_output: bool = False, resamp: Numeric = 1.5, show_progress: bool = True, **kwargs) -&gt; xarray.Dataset | tuple(xarray.Dataset, xarray.Dataset):\n\"\"\"Run GLOW model looking along heading from the current location and return the model output in\n    (ZA, R) local coordinates where ZA is zenith angle in radians and R is distance in kilometers.\n    Args:\n        time (datetime): Datetime of GLOW calculation.\n        lat (Numeric): Latitude of starting location.\n        lon (Numeric): Longitude of starting location.\n        heading (Numeric): Heading (look direction).\n        altitude (Numeric, optional): Altitude of local polar coordinate system origin in km above ASL. Must be &lt; 100 km. Defaults to 0.\n        max_alt (Numeric, optional): Maximum altitude where intersection is considered (km). Defaults to 1000, i.e. exobase.\n        n_pts (int, optional): Number of GEO coordinate angular grid points (i.e. number of GLOW runs), must be even and &gt; 20. Defaults to 50.\n        n_bins (int, optional): Number of energy bins. Defaults to 100.\n        n_alt (int, optional): Number of altitude bins, must be &gt; 100. Defaults to None, i.e. uses same number of bins as a single GLOW run.\n        with_prodloss (bool, optional): Calculate production and loss parameters in local coordinates. Defaults to False.\n        n_threads (int, optional):  Number of threads for parallel GLOW runs. Set to None to use all system threads. Defaults to None.\n        full_output (bool, optional): Returns only local coordinate GLOW output if False, and a tuple of local and GEO outputs if True. Defaults to False.\n        resamp (Numeric, optional): Number of R and ZA points in local coordinate output. ``len(R) = len(alt_km) * resamp`` and ``len(ZA) = n_pts * resamp``. Must be &gt; 0.5. Defaults to 1.5.\n        show_progress (bool, optional): Use TQDM to show progress of GLOW model calculations. Defaults to True.\n        kwargs (dict, optional): Passed to `glowpython.generic`.\n    Returns:\n        iono (xarray.Dataset): Ionospheric parameters and brightnesses (with or without production and loss) in local coordinates. This is a reference and should not be modified.\n        iono, bds (xarray.Dataset, xarray.Dataset): These values are returned only if ``full_output == True``. Both are references and should not be modified.\n        - Ionospheric parameters and brightnesses (with or without production and loss) in local coordinates.\n        - Ionospheric parameters and brightnesses (with production and loss) in GEO coordinates.\n    Raises:\n        ValueError: Number of position bins can not be odd.\n        ValueError: Number of position bins can not be &lt; 20.\n        ValueError: n_alt can not be &lt; 100.\n        ValueError: Resampling can not be &lt; 0.5.\n        ValueError: altitude must be in the range [0, 100].\n    Warns:\n        ResourceWarning: Number of threads requested is more than available system threads.\n    \"\"\"\ngrobj = glow2d_geo(time, lat, lon, heading, max_alt, n_pts, n_bins, n_alt=n_alt, uniformize_glow=True,\nn_threads=n_threads, show_progress=show_progress, **kwargs)\nbds = grobj.run_model()\ngrobj = glow2d_polar(bds, altitude, with_prodloss=with_prodloss, resamp=resamp)\niono = grobj.transform_coord()\nif not full_output:\nreturn iono\nelse:\nreturn (iono, bds)\n</code></pre> <p>Use GLOW model output evaluated on a 2D grid using <code>glow2d_geo</code> and convert it to a local ZA, R coordinate system at the origin location.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>class glow2d_polar:\n\"\"\"Use GLOW model output evaluated on a 2D grid using `glow2d_geo` and convert it to a local ZA, R coordinate system at the origin location.\n    \"\"\"\ndef __init__(self, bds: xarray.Dataset, altitude: Numeric = 0, *, with_prodloss: bool = False, resamp: Numeric = 1.5):\n\"\"\"Create a GLOWRaycast object.\n        Args:\n            bds (xarray.Dataset): GLOW model evaluated on a 2D grid using `GLOW2D`.\n            altitude (Numeric, optional): Altitude of local polar coordinate system origin in km above ASL. Must be &lt; 100 km. Defaults to 0.\n            with_prodloss (bool, optional): Calculate production and loss parameters in local coordinates. Defaults to False.\n            resamp (Numeric, optional): Number of R and ZA points in local coordinate output. ``len(R) = len(alt_km) * resamp`` and ``len(ZA) = n_pts * resamp``. Must be &gt; 0.5. Defaults to 1.5.\n        Raises:\n            ValueError: Resampling can not be &lt; 0.5.\n        \"\"\"\nif resamp &lt; 0.5:\nraise ValueError('Resampling can not be &lt; 0.5.')\nif not (0 &lt;= altitude &lt;= 100):\nraise ValueError('Altitude can not be &gt; 100 km.')\nself._resamp = resamp\nself._wprodloss = with_prodloss\nself._bds = bds.copy()\nself._iono = None\nself._r0 = altitude + EARTH_RADIUS\ndef transform_coord(self) -&gt; xarray.Dataset:\n\"\"\"Run the coordinate transform to convert GLOW output from GEO to local coordinate system.\n        Returns:\n            xarray.Dataset: GLOW output in (ZA, r) coordinates. This is a reference and should not be modified.\n        \"\"\"\nif self._iono is not None:\nreturn self._iono\ntt, rr = self.get_local_coords(\nself._bds.angle.values, self._bds.alt_km.values + EARTH_RADIUS, r0=self._r0)  # get local coords from geocentric coords\nself._rmin, self._rmax = self._bds.alt_km.values.min(), rr.max()  # nearest and farthest local pts\n# highest and lowest za\nself._tmin, self._tmax = tt.min(), np.pi / 2  # 0, tt.max()\nself._nr_num = round(len(self._bds.alt_km.values) * self._resamp)  # resample\nself._nt_num = round(len(self._bds.angle.values) * self._resamp)   # resample\noutp_shape = (self._nt_num, self._nr_num)\n# ttidx = np.where(tt &lt; 0)  # angle below horizon (LA &lt; 0)\n# # get distribution of global -&gt; local points in local grid\n# res = np.histogram2d(rr.flatten(), tt.flatten(), range=([rr.min(), rr.max()], [0, tt.max()]))\n# gd = resize(res[0], outp_shape, mode='edge')  # remap to right size\n# gd *= res[0].sum() / gd.sum()  # conserve sum of points\n# window_length = int(25 * self._resamp)  # smoothing window\n# window_length = window_length if window_length % 2 else window_length + 1  # must be odd\n# gd = savgol_filter(gd, window_length=window_length, polyorder=5, mode='nearest')  # smooth the distribution\nself._altkm = altkm = self._bds.alt_km.values  # store the altkm\nself._theta = theta = self._bds.angle.values  # store the angles\nrmin, rmax = self._rmin, self._rmax  # local names\ntmin, tmax = self._tmin, self._tmax\nself._nr = nr = np.linspace(\nrmin, rmax, self._nr_num, endpoint=True)  # local r\nself._nt = nt = np.linspace(\ntmin, tmax, self._nt_num, endpoint=True)  # local look angle\n# get meshgrid of the R, T coord system from regular r, za grid\nself._ntt, self._nrr = self.get_global_coords(nt, nr, r0=self._r0)\n# calculate jacobian\njacobian = self.get_jacobian_glob2loc_glob(self._nrr, self._ntt, r0=self._r0)\n# convert to pixel coordinates\nself._ntt = self._ntt.flatten()  # flatten T, works as _global_from_local LUT\nself._nrr = self._nrr.flatten()  # flatten R, works as _global_from_local LUT\nself._ntt = (self._ntt - self._theta.min()) / \\\n            (self._theta.max() - self._theta.min()) * \\\n            len(self._theta)  # calculate equivalent index (pixel coord) from original T grid\nself._nrr = (self._nrr - self._altkm.min() - self._r0) / \\\n            (self._altkm.max() - self._altkm.min()) * \\\n            len(self._altkm)  # calculate equivalent index (pixel coord) from original R (alt_km) grid\n# start transformation\ndata_vars = {}\nbds = self._bds\ncoord_wavelength = bds.wavelength.values  # wl axis\ncoord_state = bds.state.values  # state axis\ncoord_energy = bds.energy.values  # egrid\nbds_attr = bds.attrs  # attrs\nsingle_keys = ['Tn',\n'pedersen',\n'hall',\n'Te',\n'Ti']  # (angle, alt_km) vars\ndensity_keys = [\n'O',\n'N2',\n'O2',\n'NO',\n'NeIn',\n'NeOut',\n'ionrate',\n'O+',\n'O2+',\n'NO+',\n'N2D',\n]\nstate_keys = [\n'production',\n'loss',\n'excitedDensity'\n]  # (angle, alt_km, state) vars\n# start = perf_counter_ns()\n# map all the single key types from (angle, alt_km) -&gt; (la, r)\nfor key in single_keys:\ninp = self._bds[key].values\ninp[np.where(np.isnan(inp))] = 0\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape, mode='nearest')\nout[np.where(out &lt; 0)] = 0\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape)\ndata_vars[key] = (('za', 'r'), out)\nfor key in density_keys:\ninp = self._bds[key].values\ninp[np.where(np.isnan(inp))] = 0\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape, mode='nearest') / jacobian\nout[np.where(out &lt; 0)] = 0\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape)\ndata_vars[key] = (('za', 'r'), out)\n# end = perf_counter_ns()\n# print('Single_key conversion: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\n# dataset of (angle, alt_km) vars\niono = xarray.Dataset(data_vars=data_vars, coords={\n'za': nt, 'r': nr})\n# end = perf_counter_ns()\n# print('Single_key dataset: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nver = []\n# map all the wavelength data from (angle, alt_km, wavelength) -&gt; (la, r, wavelength)\nfor key in coord_wavelength:\ninp = bds['ver'].loc[dict(wavelength=key)].values\ninp[np.where(np.isnan(inp))] = 0\n# scaled by point distribution because flux is conserved, not brightness\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape, mode='nearest') * gd\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape, mode='nearest') / jacobian\nout[np.where(out &lt; 0)] = 0\n# inp[ttidx] = 0\n# inpsum = inp.sum()  # sum of input for valid angles\n# outpsum = out.sum()  # sum of output\n# out = out * (inpsum / outpsum)  # scale the sum to conserve total flux\nver.append(out.T)\n# end = perf_counter_ns()\n# print('VER eval: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nver = np.asarray(ver).T\nver = xr.DataArray(\nver,\ncoords={'za': nt, 'r': nr,\n'wavelength': coord_wavelength},\ndims=['za', 'r', 'wavelength'],\nname='ver'\n)  # create wl dataset\n# end = perf_counter_ns()\n# print('VER dataset: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nif self._wprodloss:\nd = {}\nfor key in state_keys:  # for each var with (angle, alt_km, state)\nres = []\ndef convert_state_stuff(st):\ninp = bds[key].loc[dict(state=st)].values\ninp[np.where(np.isnan(inp))] = 0\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape)\nout[np.where(out &lt; 0)] = 0\nif key in ('production', 'excitedDensity'):\nout /= jacobian\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape)\nreturn out.T\nres = list(map(convert_state_stuff, coord_state))\nres = np.asarray(res).T\nd[key] = (('za', 'r', 'state'), res)\n# end = perf_counter_ns()\n# print('Prod_Loss Eval: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nprodloss = xarray.Dataset(\ndata_vars=d,\ncoords={'za': nt, 'r': nr, 'state': coord_state}\n)  # calculate (angle, alt_km, state) -&gt; (la, r, state) dataset\nelse:\nprodloss = xarray.Dataset()\n# end = perf_counter_ns()\n# print('Prod_Loss DS: %.3f us'%((end - start)*1e-3))\n## EGrid conversion (angle, energy) -&gt; (r, energy) ##\n# EGrid is avaliable really at (angle, alt_km = 0, energy)\n# So we get local coords for (angle, R=R0)\n# we discard the angle information because it is meaningless, EGrid is spatial\n# start = perf_counter_ns()\n_rr, _ = self.get_local_coords(\nbds.angle.values, np.ones(bds.angle.values.shape)*self._r0, r0=self._r0)\n_rr = rr[:, 0]  # spatial EGrid\nd = []\nfor en in coord_energy:  # for each energy\ninp = bds['precip'].loc[dict(energy=en)].values\n# interpolate to appropriate energy grid\nout = np.interp(nr, _rr, inp)\nd.append(out)\nd = np.asarray(d).T\nprecip = xarray.Dataset({'precip': (('r', 'energy'), d)}, coords={\n'r': nr, 'energy': coord_energy})\n# end = perf_counter_ns()\n# print('Precip interp and ds: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\niono = xr.merge((iono, ver, prodloss, precip))  # merge all datasets\nbds_attr['altitude'] = {'values': self._r0 - EARTH_RADIUS, 'units': 'km',\n'description': 'Altitude of local polar coordinate origin ASL'}\niono.attrs.update(bds_attr)  # copy original attrs\n_ = list(map(lambda x: iono[x].attrs.update(bds[x].attrs), tuple(iono.data_vars.keys())))  # update attrs from bds\nunit_desc_dict = {\n'za': ('radians', 'Zenith angle'),\n'r': ('km', 'Radial distance in km')\n}\n_ = list(map(lambda x: iono[x].attrs.update(\n{'units': unit_desc_dict[x][0], 'description': unit_desc_dict[x][1]}), unit_desc_dict.keys()))\n# end = perf_counter_ns()\n# print('Merging: %.3f us'%((end - start)*1e-3))\nself._iono = iono\nreturn iono\n@staticmethod\ndef get_emission(iono: xarray.Dataset, feature: str = '5577', za_min: Numeric | Iterable = np.deg2rad(20), za_max: Numeric | Iterable = np.deg2rad(25), num_zapts: int = 10, *, rmin: Numeric = None, rmax: Numeric = None, num_rpts: int = 100) -&gt; float | np.ndarray:\n\"\"\"Calculate number of photons per azimuth angle (radians) per unit area per second coming from a region of (`rmin`, `rmax`, `za_min`, `za_max`).\n        Args:\n            iono (xarray.Dataset, optional): GLOW model output in local polar coordinates calculated using `glow2d.glow2d_polar.transform_coord`.\n            feature (str, optional):GLOW emission feature. Defaults to '5577'.\n            za_min (Numeric | Iterable, optional): Minimum zenith angle. Defaults to np.deg2rad(20).\n            za_max (Numeric | Iterable, optional): Maximum zenith angle. Defaults to np.deg2rad(25).\n            num_zapts (int, optional): Number of points to interpolate to. Defaults to 10.\n            rmin (Numeric, optional): Minimum distance. Defaults to None.\n            rmax (Numeric, optional): Maximum distance. Defaults to None.\n            num_rpts (int, optional): Number of distance points. The default is used only if minimum or maximum distance is not None. Defaults to 100.\n        Raises:\n            ValueError: iono is not an xarray.Dataset.\n            ValueError: ZA min and max arrays must be of the same dimension.\n            ValueError: ZA min not between 0 deg and 90 deg.\n            ValueError: ZA max is not between 0 deg and 90 deg.\n            ValueError: ZA min &gt; ZA max.\n            ValueError: Selected feature is invalid.\n        Returns:\n            float | np.ndarray: Number of photons/rad/cm^2/s\n        \"\"\"\nif iono is None or not isinstance(iono, xarray.Dataset):\nraise ValueError('iono is not an xarray.Dataset.')\nif isinstance(za_min, Iterable) or isinstance(za_max, Iterable):\nif len(za_min) != len(za_max):\nraise ValueError('ZA min and max arrays must be of the same dimension.')\ncallable = partial(glow2d_polar.get_emission, iono=iono, feature=feature,\nnum_zapts=num_zapts, rmin=rmin, rmax=rmax, num_rpts=num_rpts)\nout = list(map(lambda idx: callable(za_min=za_min[idx], za_max=za_max[idx]), range(len(za_min))))\nreturn np.asarray(out, dtype=float)\nif not (0 &lt;= za_min &lt;= np.deg2rad(90)):\nraise ValueError('ZA must be between 0 deg and 90 deg')\nif not (0 &lt;= za_max &lt;= np.deg2rad(90)):\nraise ValueError('ZA must be between 0 deg and 90 deg')\nif za_min &gt; za_max:\nraise ValueError('ZA min &gt; ZA max')\nif feature not in iono.wavelength.values:\nraise ValueError('Feature %s is invalid. Valid features: %s' % (feature, str(iono.wavelength.values)))\nza: np.ndarray = iono.za.values\nzaxis = iono.za.values\nr: np.ndarray = iono.r.values\nrr = iono.r.values\nif za_min is not None or za_max is not None:\nif (za_min == 0) and (za_max == np.deg2rad(90)):\npass\nelse:\nza_min = za.min() if za_min is None else za_min\nza_max = za.max() if za_max is None else za_max\nzaxis = np.linspace(za_min, za_max, num_zapts, endpoint=True)\nif rmin is not None or rmax is not None:\nrmin = r.min() if rmin is None else rmin\nrmax = r.max() if rmax is None else rmax\nrr = np.linspace(rmin, rmax, num_rpts, endpoint=True)\nver = iono.ver.loc[dict(wavelength=feature)].values\nver = interp2d(r, za, ver)(rr, zaxis)  # interpolate to integration axes\nver = ver*np.sin(zaxis[:, None])  # integration is VER * sin(phi) * d(phi) * d(r)\nreturn simps(simps(ver.T, zaxis), rr)  # do the double integral\n# get global coord index from local coord index, implemented as LUT\ndef _global_from_local(self, pt: tuple(int, int)) -&gt; tuple(float, float):\n# if not self.firstrun % 10000:\n#     print('Input:', pt)\ntl, rl = pt  # pixel coord\n# rl = (rl * (self._rmax - self._rmin) / self._nr_num) + self._rmin # real coord\n# tl = (tl * (self._tmax - self._tmin) / self._nt_num) + self._tmin\n# rl = self._nr[rl]\n# tl = self._nt[tl]\n# t, r = self._get_global_coords(tl, rl)\n# # if not self.firstrun % 10000:\n# #     print((rl, tl), '-&gt;', (r, t), ':', (self._altkm.min(), self._altkm.max()))\n# r = (r - self._altkm.min() - EARTH_RADIUS) / (self._altkm.max() - self._altkm.min()) * len(self._altkm)\n# t = (t - self._theta.min()) / (self._theta.max() - self._theta.min()) * len(self._theta)\n# if not self.firstrun % 10000:\n#     print((float(r), float(t)))\nreturn (float(self._ntt[tl*self._nr_num + rl]), float(self._nrr[tl*self._nr_num + rl]))\n@staticmethod\ndef get_global_coords(t: np.ndarray | Numeric, r: np.ndarray | Numeric, r0: Numeric = EARTH_RADIUS, meshgrid: bool = True) -&gt; tuple(np.ndarray, np.ndarray):\n\"\"\"Get GEO coordinates from local coordinates.\n        $$\n            R = \\\\sqrt{\\\\left\\\\{ (r\\\\cos{\\\\phi} + R_0)^2 + r^2\\\\sin{\\\\phi}^2 \\\\right\\\\}}, \\\\\\\\\n            \\\\theta = \\\\arctan{\\\\frac{r\\\\sin{\\\\phi}}{r\\\\cos{\\\\phi} + R_0}}\n        $$\n        Args:\n            t (np.ndarray | Numeric): Angles in radians.\n            r (np.ndarray | Numeric): Distance in km.\n            r0 (Numeric, optional): Distance to origin. Defaults to geopy.distance.EARTH_RADIUS.\n            meshgrid (bool, optional): Optionally convert 1-D inputs to a meshgrid. Defaults to True.\n        Raises:\n            ValueError: ``r`` and ``t`` does not have the same dimensions\n            TypeError: ``r`` and ``t`` are not ``numpy.ndarray``.\n        Returns:\n            (np.ndarray, np.ndarray): (angles, distances) in GEO coordinates.\n        \"\"\"\nif isinstance(r, np.ndarray) and isinstance(t, np.ndarray):  # if array\nif r.ndim != t.ndim:  # if dims don't match get out\nraise ValueError('r and t does not have the same dimensions')\nif r.ndim == 1 and meshgrid:\n_r, _t = np.meshgrid(r, t)\nelif r.ndim == 1 and not meshgrid:\n_r, _t = r, t\nelse:\n_r, _t = r.copy(), t.copy()  # already a meshgrid?\nr = _r[0]\nt = _t[:, 0]\nelif isinstance(r, Numeric) and isinstance(t, Numeric):  # floats\n_r = np.atleast_1d(r)\n_t = np.atleast_1d(t)\nelse:\nraise TypeError('r and t must be np.ndarray.')\n# _t = np.pi/2 - _t\nrr = np.sqrt((_r*np.cos(_t) + r0)**2 +\n(_r*np.sin(_t))**2)  # r, la to R, T\ntt = np.arctan2(_r*np.sin(_t), _r*np.cos(_t) + r0)\nreturn tt, rr\n@staticmethod\ndef get_local_coords(t: np.ndarray | Numeric, r: np.ndarray | Numeric, r0: Numeric = EARTH_RADIUS, meshgrid: bool = True) -&gt; tuple(np.ndarray, np.ndarray):\n\"\"\"Get local coordinates from GEO coordinates.\n        $$\n            r = \\\\sqrt{\\\\left\\\\{ (R\\\\cos{\\\\theta} - R_0)^2 + R^2\\\\sin{\\\\theta}^2 \\\\right\\\\}}, \\\\\\\\\n            \\\\phi = \\\\arctan{\\\\frac{R\\\\sin{\\\\theta}}{R\\\\cos{\\\\theta} - R_0}}\n        $$\n        Args:\n            t (np.ndarray | Numeric): Angles in radians.\n            r (np.ndarray | Numeric): Distance in km.\n            r0 (Numeric, optional): Distance to origin. Defaults to geopy.distance.EARTH_RADIUS.\n            meshgrid (bool, optional): Optionally convert 1-D inputs to a meshgrid. Defaults to True.\n        Raises:\n            ValueError: ``r`` and ``t`` does not have the same dimensions\n            TypeError: ``r`` and ``t`` are not ``numpy.ndarray``.\n        Returns:\n            (np.ndarray, np.ndarray): (angles, distances) in local coordinates.\n        \"\"\"\nif isinstance(r, np.ndarray) and isinstance(t, np.ndarray):\nif r.ndim != t.ndim:  # if dims don't match get out\nraise ValueError('r and t does not have the same dimensions')\nif r.ndim == 1 and meshgrid:\n_r, _t = np.meshgrid(r, t)\nelif r.ndim == 1 and not meshgrid:\n_r, _t = r, t\nelse:\n_r, _t = r.copy(), t.copy()  # already a meshgrid?\nr = _r[0]\nt = _t[:, 0]\nelif isinstance(r, Numeric) and isinstance(t, Numeric):\n_r = np.atleast_1d(r)\n_t = np.atleast_1d(t)\nelse:\nraise TypeError('r and t must be np.ndarray.')\nrr = np.sqrt((_r*np.cos(_t) - r0)**2 +\n(_r*np.sin(_t))**2)  # R, T to r, la\ntt = np.arctan2(_r*np.sin(_t), _r*np.cos(_t) - r0)\nreturn tt, rr\n@staticmethod\ndef get_jacobian_glob2loc_loc(r: np.ndarray, t: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian \\\\(|J_{R\\\\rightarrow r}|\\\\) for global to local coordinate transform, evaluated at points in local coordinate.\n        $$\n            |J_{R\\\\rightarrow r}| = \\\\frac{R}{r^3}\\\\left(R^2 + R_0^2 - 2 R R_0 \\\\cos{\\\\theta}\\\\right)\n        $$\n        Args:\n            r (np.ndarray): 2-dimensional array of r.\n            t (np.ndarray): 2-dimensional array of phi.\n            r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n        Raises:\n            ValueError: Dimension of inputs must be 2.\n        Returns:\n            np.ndarray: Jacobian evaluated at points.\n        \"\"\"\nif r.ndim != 2 or t.ndim != 2:\nraise ValueError('Dimension of inputs must be 2.')\ngt, gr = glow2d_polar.get_global_coords(t, r, r0=r0)\njac = (gr / (r**3)) * ((gr**2) + (r0**2) - (2*gr*r0*np.cos(gt)))\nreturn jac\n@staticmethod\ndef get_jacobian_loc2glob_loc(r: np.ndarray, t: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian \\\\(|J_{r\\\\rightarrow R}|\\\\) for local to global coordinate transform, evaluated at points in local coordinate.\n        $$\n            |J_{r\\\\rightarrow R}| = \\\\frac{r}{R^3}\\\\left(r^2 + R_0^2 + 2 r R_0 \\\\cos{\\\\phi}\\\\right)\n        $$\n        Args:\n            r (np.ndarray): 2-dimensional array of r.\n            t (np.ndarray): 2-dimensional array of phi.\n            r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n        Raises:\n            ValueError: Dimension of inputs must be 2.\n        Returns:\n            np.ndarray: Jacobian evaluated at points.\n        \"\"\"\nif r.ndim != 2 or t.ndim != 2:\nraise ValueError('Dimension of inputs must be 2')\ngt, gr = glow2d_polar.get_global_coords(t, r, r0=r0)\njac = (r/(gr**3))*((r**2) + (r0**2) + (2*r*r0*np.cos(t)))\nreturn jac\n@staticmethod\ndef get_jacobian_glob2loc_glob(gr: np.ndarray, gt: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian determinant \\\\(|J_{R\\\\rightarrow r}|\\\\) for global to local coordinate transform, evaluated at points in global coordinate.\n        $$\n            |J_{R\\\\rightarrow r}| = \\\\frac{R}{r^3}\\\\left(R^2 + R_0^2 - 2 R R_0 \\\\cos{\\\\theta}\\\\right)\n        $$\n        Args:\n            gr (np.ndarray): 2-dimensional array of R.\n            gt (np.ndarray): 2-dimensional array of Theta.\n            r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n        Raises:\n            ValueError: Dimension of inputs must be 2.\n        Returns:\n            np.ndarray: Jacobian evaluated at points.\n        \"\"\"\nif gr.ndim != 2 or gt.ndim != 2:\nraise ValueError('Dimension of inputs must be 2')\nt, r = glow2d_polar.get_local_coords(gt, gr, r0=r0)\njac = (gr / (r**3)) * ((gr**2) + (r0**2) - (2*gr*r0*np.cos(gt)))\nreturn jac\n@staticmethod\ndef get_jacobian_loc2glob_glob(gr: np.ndarray, gt: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian \\\\(|J_{r\\\\rightarrow R}|\\\\) for global to local coordinate transform, evaluated at points in local coordinate.\n        $$\n            |J_{r\\\\rightarrow R}| = \\\\frac{r}{R^3}\\\\left(r^2 + R_0^2 + 2 r R_0 \\\\cos{\\\\phi}\\\\right)\n        $$\n        Args:\n            gr (np.ndarray): 2-dimensional array of R.\n            gt (np.ndarray): 2-dimensional array of Theta.\n            r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n        Raises:\n            ValueError: Dimension of inputs must be 2.\n        Returns:\n            np.ndarray: Jacobian evaluated at points.\n        \"\"\"\nif gr.ndim != 2 or gt.ndim != 2:\nraise ValueError('Dimension of inputs must be 2')\nt, r = glow2d_polar.get_local_coords(gt, gr, r0=EARTH_RADIUS)\njac = (r/(gr**3))*((r**2) + (r0**2) + (2*r*r0*np.cos(t)))\nreturn jac\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.__init__","title":"<code>__init__(bds, altitude=0, *, with_prodloss=False, resamp=1.5)</code>","text":"<p>Create a GLOWRaycast object.</p> <p>Parameters:</p> Name Type Description Default <code>bds</code> <code>xarray.Dataset</code> <p>GLOW model evaluated on a 2D grid using <code>GLOW2D</code>.</p> required <code>altitude</code> <code>Numeric</code> <p>Altitude of local polar coordinate system origin in km above ASL. Must be &lt; 100 km. Defaults to 0.</p> <code>0</code> <code>with_prodloss</code> <code>bool</code> <p>Calculate production and loss parameters in local coordinates. Defaults to False.</p> <code>False</code> <code>resamp</code> <code>Numeric</code> <p>Number of R and ZA points in local coordinate output. <code>len(R) = len(alt_km) * resamp</code> and <code>len(ZA) = n_pts * resamp</code>. Must be &gt; 0.5. Defaults to 1.5.</p> <code>1.5</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Resampling can not be &lt; 0.5.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>def __init__(self, bds: xarray.Dataset, altitude: Numeric = 0, *, with_prodloss: bool = False, resamp: Numeric = 1.5):\n\"\"\"Create a GLOWRaycast object.\n    Args:\n        bds (xarray.Dataset): GLOW model evaluated on a 2D grid using `GLOW2D`.\n        altitude (Numeric, optional): Altitude of local polar coordinate system origin in km above ASL. Must be &lt; 100 km. Defaults to 0.\n        with_prodloss (bool, optional): Calculate production and loss parameters in local coordinates. Defaults to False.\n        resamp (Numeric, optional): Number of R and ZA points in local coordinate output. ``len(R) = len(alt_km) * resamp`` and ``len(ZA) = n_pts * resamp``. Must be &gt; 0.5. Defaults to 1.5.\n    Raises:\n        ValueError: Resampling can not be &lt; 0.5.\n    \"\"\"\nif resamp &lt; 0.5:\nraise ValueError('Resampling can not be &lt; 0.5.')\nif not (0 &lt;= altitude &lt;= 100):\nraise ValueError('Altitude can not be &gt; 100 km.')\nself._resamp = resamp\nself._wprodloss = with_prodloss\nself._bds = bds.copy()\nself._iono = None\nself._r0 = altitude + EARTH_RADIUS\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_emission","title":"<code>get_emission(iono, feature='5577', za_min=np.deg2rad(20), za_max=np.deg2rad(25), num_zapts=10, *, rmin=None, rmax=None, num_rpts=100)</code>  <code>staticmethod</code>","text":"<p>Calculate number of photons per azimuth angle (radians) per unit area per second coming from a region of (<code>rmin</code>, <code>rmax</code>, <code>za_min</code>, <code>za_max</code>).</p> <p>Parameters:</p> Name Type Description Default <code>iono</code> <code>xarray.Dataset</code> <p>GLOW model output in local polar coordinates calculated using <code>glow2d.glow2d_polar.transform_coord</code>.</p> required <code>feature</code> <code>str</code> <p>GLOW emission feature. Defaults to '5577'.</p> <code>'5577'</code> <code>za_min</code> <code>Numeric | Iterable</code> <p>Minimum zenith angle. Defaults to np.deg2rad(20).</p> <code>np.deg2rad(20)</code> <code>za_max</code> <code>Numeric | Iterable</code> <p>Maximum zenith angle. Defaults to np.deg2rad(25).</p> <code>np.deg2rad(25)</code> <code>num_zapts</code> <code>int</code> <p>Number of points to interpolate to. Defaults to 10.</p> <code>10</code> <code>rmin</code> <code>Numeric</code> <p>Minimum distance. Defaults to None.</p> <code>None</code> <code>rmax</code> <code>Numeric</code> <p>Maximum distance. Defaults to None.</p> <code>None</code> <code>num_rpts</code> <code>int</code> <p>Number of distance points. The default is used only if minimum or maximum distance is not None. Defaults to 100.</p> <code>100</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>iono is not an xarray.Dataset.</p> <code>ValueError</code> <p>ZA min and max arrays must be of the same dimension.</p> <code>ValueError</code> <p>ZA min not between 0 deg and 90 deg.</p> <code>ValueError</code> <p>ZA max is not between 0 deg and 90 deg.</p> <code>ValueError</code> <p>ZA min &gt; ZA max.</p> <code>ValueError</code> <p>Selected feature is invalid.</p> <p>Returns:</p> Type Description <code>float | np.ndarray</code> <p>float | np.ndarray: Number of photons/rad/cm^2/s</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_emission(iono: xarray.Dataset, feature: str = '5577', za_min: Numeric | Iterable = np.deg2rad(20), za_max: Numeric | Iterable = np.deg2rad(25), num_zapts: int = 10, *, rmin: Numeric = None, rmax: Numeric = None, num_rpts: int = 100) -&gt; float | np.ndarray:\n\"\"\"Calculate number of photons per azimuth angle (radians) per unit area per second coming from a region of (`rmin`, `rmax`, `za_min`, `za_max`).\n    Args:\n        iono (xarray.Dataset, optional): GLOW model output in local polar coordinates calculated using `glow2d.glow2d_polar.transform_coord`.\n        feature (str, optional):GLOW emission feature. Defaults to '5577'.\n        za_min (Numeric | Iterable, optional): Minimum zenith angle. Defaults to np.deg2rad(20).\n        za_max (Numeric | Iterable, optional): Maximum zenith angle. Defaults to np.deg2rad(25).\n        num_zapts (int, optional): Number of points to interpolate to. Defaults to 10.\n        rmin (Numeric, optional): Minimum distance. Defaults to None.\n        rmax (Numeric, optional): Maximum distance. Defaults to None.\n        num_rpts (int, optional): Number of distance points. The default is used only if minimum or maximum distance is not None. Defaults to 100.\n    Raises:\n        ValueError: iono is not an xarray.Dataset.\n        ValueError: ZA min and max arrays must be of the same dimension.\n        ValueError: ZA min not between 0 deg and 90 deg.\n        ValueError: ZA max is not between 0 deg and 90 deg.\n        ValueError: ZA min &gt; ZA max.\n        ValueError: Selected feature is invalid.\n    Returns:\n        float | np.ndarray: Number of photons/rad/cm^2/s\n    \"\"\"\nif iono is None or not isinstance(iono, xarray.Dataset):\nraise ValueError('iono is not an xarray.Dataset.')\nif isinstance(za_min, Iterable) or isinstance(za_max, Iterable):\nif len(za_min) != len(za_max):\nraise ValueError('ZA min and max arrays must be of the same dimension.')\ncallable = partial(glow2d_polar.get_emission, iono=iono, feature=feature,\nnum_zapts=num_zapts, rmin=rmin, rmax=rmax, num_rpts=num_rpts)\nout = list(map(lambda idx: callable(za_min=za_min[idx], za_max=za_max[idx]), range(len(za_min))))\nreturn np.asarray(out, dtype=float)\nif not (0 &lt;= za_min &lt;= np.deg2rad(90)):\nraise ValueError('ZA must be between 0 deg and 90 deg')\nif not (0 &lt;= za_max &lt;= np.deg2rad(90)):\nraise ValueError('ZA must be between 0 deg and 90 deg')\nif za_min &gt; za_max:\nraise ValueError('ZA min &gt; ZA max')\nif feature not in iono.wavelength.values:\nraise ValueError('Feature %s is invalid. Valid features: %s' % (feature, str(iono.wavelength.values)))\nza: np.ndarray = iono.za.values\nzaxis = iono.za.values\nr: np.ndarray = iono.r.values\nrr = iono.r.values\nif za_min is not None or za_max is not None:\nif (za_min == 0) and (za_max == np.deg2rad(90)):\npass\nelse:\nza_min = za.min() if za_min is None else za_min\nza_max = za.max() if za_max is None else za_max\nzaxis = np.linspace(za_min, za_max, num_zapts, endpoint=True)\nif rmin is not None or rmax is not None:\nrmin = r.min() if rmin is None else rmin\nrmax = r.max() if rmax is None else rmax\nrr = np.linspace(rmin, rmax, num_rpts, endpoint=True)\nver = iono.ver.loc[dict(wavelength=feature)].values\nver = interp2d(r, za, ver)(rr, zaxis)  # interpolate to integration axes\nver = ver*np.sin(zaxis[:, None])  # integration is VER * sin(phi) * d(phi) * d(r)\nreturn simps(simps(ver.T, zaxis), rr)  # do the double integral\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_global_coords","title":"<code>get_global_coords(t, r, r0=EARTH_RADIUS, meshgrid=True)</code>  <code>staticmethod</code>","text":"<p>Get GEO coordinates from local coordinates.</p> <p> </p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>np.ndarray | Numeric</code> <p>Angles in radians.</p> required <code>r</code> <code>np.ndarray | Numeric</code> <p>Distance in km.</p> required <code>r0</code> <code>Numeric</code> <p>Distance to origin. Defaults to geopy.distance.EARTH_RADIUS.</p> <code>EARTH_RADIUS</code> <code>meshgrid</code> <code>bool</code> <p>Optionally convert 1-D inputs to a meshgrid. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>r</code> and <code>t</code> does not have the same dimensions</p> <code>TypeError</code> <p><code>r</code> and <code>t</code> are not <code>numpy.ndarray</code>.</p> <p>Returns:</p> Type Description <code>np.ndarray, np.ndarray</code> <p>(angles, distances) in GEO coordinates.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_global_coords(t: np.ndarray | Numeric, r: np.ndarray | Numeric, r0: Numeric = EARTH_RADIUS, meshgrid: bool = True) -&gt; tuple(np.ndarray, np.ndarray):\n\"\"\"Get GEO coordinates from local coordinates.\n    $$\n        R = \\\\sqrt{\\\\left\\\\{ (r\\\\cos{\\\\phi} + R_0)^2 + r^2\\\\sin{\\\\phi}^2 \\\\right\\\\}}, \\\\\\\\\n        \\\\theta = \\\\arctan{\\\\frac{r\\\\sin{\\\\phi}}{r\\\\cos{\\\\phi} + R_0}}\n    $$\n    Args:\n        t (np.ndarray | Numeric): Angles in radians.\n        r (np.ndarray | Numeric): Distance in km.\n        r0 (Numeric, optional): Distance to origin. Defaults to geopy.distance.EARTH_RADIUS.\n        meshgrid (bool, optional): Optionally convert 1-D inputs to a meshgrid. Defaults to True.\n    Raises:\n        ValueError: ``r`` and ``t`` does not have the same dimensions\n        TypeError: ``r`` and ``t`` are not ``numpy.ndarray``.\n    Returns:\n        (np.ndarray, np.ndarray): (angles, distances) in GEO coordinates.\n    \"\"\"\nif isinstance(r, np.ndarray) and isinstance(t, np.ndarray):  # if array\nif r.ndim != t.ndim:  # if dims don't match get out\nraise ValueError('r and t does not have the same dimensions')\nif r.ndim == 1 and meshgrid:\n_r, _t = np.meshgrid(r, t)\nelif r.ndim == 1 and not meshgrid:\n_r, _t = r, t\nelse:\n_r, _t = r.copy(), t.copy()  # already a meshgrid?\nr = _r[0]\nt = _t[:, 0]\nelif isinstance(r, Numeric) and isinstance(t, Numeric):  # floats\n_r = np.atleast_1d(r)\n_t = np.atleast_1d(t)\nelse:\nraise TypeError('r and t must be np.ndarray.')\n# _t = np.pi/2 - _t\nrr = np.sqrt((_r*np.cos(_t) + r0)**2 +\n(_r*np.sin(_t))**2)  # r, la to R, T\ntt = np.arctan2(_r*np.sin(_t), _r*np.cos(_t) + r0)\nreturn tt, rr\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_jacobian_glob2loc_glob","title":"<code>get_jacobian_glob2loc_glob(gr, gt, r0=EARTH_RADIUS)</code>  <code>staticmethod</code>","text":"<p>Jacobian determinant |J_{R\\rightarrow r}| for global to local coordinate transform, evaluated at points in global coordinate.</p> <p>      |J_{R\\rightarrow r}| = \\frac{R}{r^3}\\left(R^2 + R_0^2 - 2 R R_0 \\cos{\\theta}\\right)  </p> <p>Parameters:</p> Name Type Description Default <code>gr</code> <code>np.ndarray</code> <p>2-dimensional array of R.</p> required <code>gt</code> <code>np.ndarray</code> <p>2-dimensional array of Theta.</p> required <code>r0</code> <code>Numeric</code> <p>Coordinate transform offset. Defaults to EARTH_RADIUS.</p> <code>EARTH_RADIUS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Dimension of inputs must be 2.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Jacobian evaluated at points.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_jacobian_glob2loc_glob(gr: np.ndarray, gt: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian determinant \\\\(|J_{R\\\\rightarrow r}|\\\\) for global to local coordinate transform, evaluated at points in global coordinate.\n    $$\n        |J_{R\\\\rightarrow r}| = \\\\frac{R}{r^3}\\\\left(R^2 + R_0^2 - 2 R R_0 \\\\cos{\\\\theta}\\\\right)\n    $$\n    Args:\n        gr (np.ndarray): 2-dimensional array of R.\n        gt (np.ndarray): 2-dimensional array of Theta.\n        r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n    Raises:\n        ValueError: Dimension of inputs must be 2.\n    Returns:\n        np.ndarray: Jacobian evaluated at points.\n    \"\"\"\nif gr.ndim != 2 or gt.ndim != 2:\nraise ValueError('Dimension of inputs must be 2')\nt, r = glow2d_polar.get_local_coords(gt, gr, r0=r0)\njac = (gr / (r**3)) * ((gr**2) + (r0**2) - (2*gr*r0*np.cos(gt)))\nreturn jac\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_jacobian_glob2loc_loc","title":"<code>get_jacobian_glob2loc_loc(r, t, r0=EARTH_RADIUS)</code>  <code>staticmethod</code>","text":"<p>Jacobian |J_{R\\rightarrow r}| for global to local coordinate transform, evaluated at points in local coordinate.</p> <p>      |J_{R\\rightarrow r}| = \\frac{R}{r^3}\\left(R^2 + R_0^2 - 2 R R_0 \\cos{\\theta}\\right)  </p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>np.ndarray</code> <p>2-dimensional array of r.</p> required <code>t</code> <code>np.ndarray</code> <p>2-dimensional array of phi.</p> required <code>r0</code> <code>Numeric</code> <p>Coordinate transform offset. Defaults to EARTH_RADIUS.</p> <code>EARTH_RADIUS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Dimension of inputs must be 2.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Jacobian evaluated at points.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_jacobian_glob2loc_loc(r: np.ndarray, t: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian \\\\(|J_{R\\\\rightarrow r}|\\\\) for global to local coordinate transform, evaluated at points in local coordinate.\n    $$\n        |J_{R\\\\rightarrow r}| = \\\\frac{R}{r^3}\\\\left(R^2 + R_0^2 - 2 R R_0 \\\\cos{\\\\theta}\\\\right)\n    $$\n    Args:\n        r (np.ndarray): 2-dimensional array of r.\n        t (np.ndarray): 2-dimensional array of phi.\n        r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n    Raises:\n        ValueError: Dimension of inputs must be 2.\n    Returns:\n        np.ndarray: Jacobian evaluated at points.\n    \"\"\"\nif r.ndim != 2 or t.ndim != 2:\nraise ValueError('Dimension of inputs must be 2.')\ngt, gr = glow2d_polar.get_global_coords(t, r, r0=r0)\njac = (gr / (r**3)) * ((gr**2) + (r0**2) - (2*gr*r0*np.cos(gt)))\nreturn jac\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_jacobian_loc2glob_glob","title":"<code>get_jacobian_loc2glob_glob(gr, gt, r0=EARTH_RADIUS)</code>  <code>staticmethod</code>","text":"<p>Jacobian |J_{r\\rightarrow R}| for global to local coordinate transform, evaluated at points in local coordinate.</p> <p>      |J_{r\\rightarrow R}| = \\frac{r}{R^3}\\left(r^2 + R_0^2 + 2 r R_0 \\cos{\\phi}\\right)  </p> <p>Parameters:</p> Name Type Description Default <code>gr</code> <code>np.ndarray</code> <p>2-dimensional array of R.</p> required <code>gt</code> <code>np.ndarray</code> <p>2-dimensional array of Theta.</p> required <code>r0</code> <code>Numeric</code> <p>Coordinate transform offset. Defaults to EARTH_RADIUS.</p> <code>EARTH_RADIUS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Dimension of inputs must be 2.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Jacobian evaluated at points.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_jacobian_loc2glob_glob(gr: np.ndarray, gt: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian \\\\(|J_{r\\\\rightarrow R}|\\\\) for global to local coordinate transform, evaluated at points in local coordinate.\n    $$\n        |J_{r\\\\rightarrow R}| = \\\\frac{r}{R^3}\\\\left(r^2 + R_0^2 + 2 r R_0 \\\\cos{\\\\phi}\\\\right)\n    $$\n    Args:\n        gr (np.ndarray): 2-dimensional array of R.\n        gt (np.ndarray): 2-dimensional array of Theta.\n        r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n    Raises:\n        ValueError: Dimension of inputs must be 2.\n    Returns:\n        np.ndarray: Jacobian evaluated at points.\n    \"\"\"\nif gr.ndim != 2 or gt.ndim != 2:\nraise ValueError('Dimension of inputs must be 2')\nt, r = glow2d_polar.get_local_coords(gt, gr, r0=EARTH_RADIUS)\njac = (r/(gr**3))*((r**2) + (r0**2) + (2*r*r0*np.cos(t)))\nreturn jac\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_jacobian_loc2glob_loc","title":"<code>get_jacobian_loc2glob_loc(r, t, r0=EARTH_RADIUS)</code>  <code>staticmethod</code>","text":"<p>Jacobian |J_{r\\rightarrow R}| for local to global coordinate transform, evaluated at points in local coordinate.</p> <p>      |J_{r\\rightarrow R}| = \\frac{r}{R^3}\\left(r^2 + R_0^2 + 2 r R_0 \\cos{\\phi}\\right)  </p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>np.ndarray</code> <p>2-dimensional array of r.</p> required <code>t</code> <code>np.ndarray</code> <p>2-dimensional array of phi.</p> required <code>r0</code> <code>Numeric</code> <p>Coordinate transform offset. Defaults to EARTH_RADIUS.</p> <code>EARTH_RADIUS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Dimension of inputs must be 2.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Jacobian evaluated at points.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_jacobian_loc2glob_loc(r: np.ndarray, t: np.ndarray, r0: Numeric = EARTH_RADIUS) -&gt; np.ndarray:\n\"\"\"Jacobian \\\\(|J_{r\\\\rightarrow R}|\\\\) for local to global coordinate transform, evaluated at points in local coordinate.\n    $$\n        |J_{r\\\\rightarrow R}| = \\\\frac{r}{R^3}\\\\left(r^2 + R_0^2 + 2 r R_0 \\\\cos{\\\\phi}\\\\right)\n    $$\n    Args:\n        r (np.ndarray): 2-dimensional array of r.\n        t (np.ndarray): 2-dimensional array of phi.\n        r0 (Numeric): Coordinate transform offset. Defaults to EARTH_RADIUS.\n    Raises:\n        ValueError: Dimension of inputs must be 2.\n    Returns:\n        np.ndarray: Jacobian evaluated at points.\n    \"\"\"\nif r.ndim != 2 or t.ndim != 2:\nraise ValueError('Dimension of inputs must be 2')\ngt, gr = glow2d_polar.get_global_coords(t, r, r0=r0)\njac = (r/(gr**3))*((r**2) + (r0**2) + (2*r*r0*np.cos(t)))\nreturn jac\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.get_local_coords","title":"<code>get_local_coords(t, r, r0=EARTH_RADIUS, meshgrid=True)</code>  <code>staticmethod</code>","text":"<p>Get local coordinates from GEO coordinates.</p> <p>      r = \\sqrt{\\left\\{ (R\\cos{\\theta} - R_0)^2 + R^2\\sin{\\theta}^2 \\right\\}}, \\\\     \\phi = \\arctan{\\frac{R\\sin{\\theta}}{R\\cos{\\theta} - R_0}}  </p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>np.ndarray | Numeric</code> <p>Angles in radians.</p> required <code>r</code> <code>np.ndarray | Numeric</code> <p>Distance in km.</p> required <code>r0</code> <code>Numeric</code> <p>Distance to origin. Defaults to geopy.distance.EARTH_RADIUS.</p> <code>EARTH_RADIUS</code> <code>meshgrid</code> <code>bool</code> <p>Optionally convert 1-D inputs to a meshgrid. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>r</code> and <code>t</code> does not have the same dimensions</p> <code>TypeError</code> <p><code>r</code> and <code>t</code> are not <code>numpy.ndarray</code>.</p> <p>Returns:</p> Type Description <code>np.ndarray, np.ndarray</code> <p>(angles, distances) in local coordinates.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>@staticmethod\ndef get_local_coords(t: np.ndarray | Numeric, r: np.ndarray | Numeric, r0: Numeric = EARTH_RADIUS, meshgrid: bool = True) -&gt; tuple(np.ndarray, np.ndarray):\n\"\"\"Get local coordinates from GEO coordinates.\n    $$\n        r = \\\\sqrt{\\\\left\\\\{ (R\\\\cos{\\\\theta} - R_0)^2 + R^2\\\\sin{\\\\theta}^2 \\\\right\\\\}}, \\\\\\\\\n        \\\\phi = \\\\arctan{\\\\frac{R\\\\sin{\\\\theta}}{R\\\\cos{\\\\theta} - R_0}}\n    $$\n    Args:\n        t (np.ndarray | Numeric): Angles in radians.\n        r (np.ndarray | Numeric): Distance in km.\n        r0 (Numeric, optional): Distance to origin. Defaults to geopy.distance.EARTH_RADIUS.\n        meshgrid (bool, optional): Optionally convert 1-D inputs to a meshgrid. Defaults to True.\n    Raises:\n        ValueError: ``r`` and ``t`` does not have the same dimensions\n        TypeError: ``r`` and ``t`` are not ``numpy.ndarray``.\n    Returns:\n        (np.ndarray, np.ndarray): (angles, distances) in local coordinates.\n    \"\"\"\nif isinstance(r, np.ndarray) and isinstance(t, np.ndarray):\nif r.ndim != t.ndim:  # if dims don't match get out\nraise ValueError('r and t does not have the same dimensions')\nif r.ndim == 1 and meshgrid:\n_r, _t = np.meshgrid(r, t)\nelif r.ndim == 1 and not meshgrid:\n_r, _t = r, t\nelse:\n_r, _t = r.copy(), t.copy()  # already a meshgrid?\nr = _r[0]\nt = _t[:, 0]\nelif isinstance(r, Numeric) and isinstance(t, Numeric):\n_r = np.atleast_1d(r)\n_t = np.atleast_1d(t)\nelse:\nraise TypeError('r and t must be np.ndarray.')\nrr = np.sqrt((_r*np.cos(_t) - r0)**2 +\n(_r*np.sin(_t))**2)  # R, T to r, la\ntt = np.arctan2(_r*np.sin(_t), _r*np.cos(_t) - r0)\nreturn tt, rr\n</code></pre>"},{"location":"overview/#glow2d._glow2d.glow2d_polar.transform_coord","title":"<code>transform_coord()</code>","text":"<p>Run the coordinate transform to convert GLOW output from GEO to local coordinate system.</p> <p>Returns:</p> Type Description <code>xarray.Dataset</code> <p>xarray.Dataset: GLOW output in (ZA, r) coordinates. This is a reference and should not be modified.</p> Source code in <code>glow2d/_glow2d.py</code> <pre><code>def transform_coord(self) -&gt; xarray.Dataset:\n\"\"\"Run the coordinate transform to convert GLOW output from GEO to local coordinate system.\n    Returns:\n        xarray.Dataset: GLOW output in (ZA, r) coordinates. This is a reference and should not be modified.\n    \"\"\"\nif self._iono is not None:\nreturn self._iono\ntt, rr = self.get_local_coords(\nself._bds.angle.values, self._bds.alt_km.values + EARTH_RADIUS, r0=self._r0)  # get local coords from geocentric coords\nself._rmin, self._rmax = self._bds.alt_km.values.min(), rr.max()  # nearest and farthest local pts\n# highest and lowest za\nself._tmin, self._tmax = tt.min(), np.pi / 2  # 0, tt.max()\nself._nr_num = round(len(self._bds.alt_km.values) * self._resamp)  # resample\nself._nt_num = round(len(self._bds.angle.values) * self._resamp)   # resample\noutp_shape = (self._nt_num, self._nr_num)\n# ttidx = np.where(tt &lt; 0)  # angle below horizon (LA &lt; 0)\n# # get distribution of global -&gt; local points in local grid\n# res = np.histogram2d(rr.flatten(), tt.flatten(), range=([rr.min(), rr.max()], [0, tt.max()]))\n# gd = resize(res[0], outp_shape, mode='edge')  # remap to right size\n# gd *= res[0].sum() / gd.sum()  # conserve sum of points\n# window_length = int(25 * self._resamp)  # smoothing window\n# window_length = window_length if window_length % 2 else window_length + 1  # must be odd\n# gd = savgol_filter(gd, window_length=window_length, polyorder=5, mode='nearest')  # smooth the distribution\nself._altkm = altkm = self._bds.alt_km.values  # store the altkm\nself._theta = theta = self._bds.angle.values  # store the angles\nrmin, rmax = self._rmin, self._rmax  # local names\ntmin, tmax = self._tmin, self._tmax\nself._nr = nr = np.linspace(\nrmin, rmax, self._nr_num, endpoint=True)  # local r\nself._nt = nt = np.linspace(\ntmin, tmax, self._nt_num, endpoint=True)  # local look angle\n# get meshgrid of the R, T coord system from regular r, za grid\nself._ntt, self._nrr = self.get_global_coords(nt, nr, r0=self._r0)\n# calculate jacobian\njacobian = self.get_jacobian_glob2loc_glob(self._nrr, self._ntt, r0=self._r0)\n# convert to pixel coordinates\nself._ntt = self._ntt.flatten()  # flatten T, works as _global_from_local LUT\nself._nrr = self._nrr.flatten()  # flatten R, works as _global_from_local LUT\nself._ntt = (self._ntt - self._theta.min()) / \\\n        (self._theta.max() - self._theta.min()) * \\\n        len(self._theta)  # calculate equivalent index (pixel coord) from original T grid\nself._nrr = (self._nrr - self._altkm.min() - self._r0) / \\\n        (self._altkm.max() - self._altkm.min()) * \\\n        len(self._altkm)  # calculate equivalent index (pixel coord) from original R (alt_km) grid\n# start transformation\ndata_vars = {}\nbds = self._bds\ncoord_wavelength = bds.wavelength.values  # wl axis\ncoord_state = bds.state.values  # state axis\ncoord_energy = bds.energy.values  # egrid\nbds_attr = bds.attrs  # attrs\nsingle_keys = ['Tn',\n'pedersen',\n'hall',\n'Te',\n'Ti']  # (angle, alt_km) vars\ndensity_keys = [\n'O',\n'N2',\n'O2',\n'NO',\n'NeIn',\n'NeOut',\n'ionrate',\n'O+',\n'O2+',\n'NO+',\n'N2D',\n]\nstate_keys = [\n'production',\n'loss',\n'excitedDensity'\n]  # (angle, alt_km, state) vars\n# start = perf_counter_ns()\n# map all the single key types from (angle, alt_km) -&gt; (la, r)\nfor key in single_keys:\ninp = self._bds[key].values\ninp[np.where(np.isnan(inp))] = 0\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape, mode='nearest')\nout[np.where(out &lt; 0)] = 0\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape)\ndata_vars[key] = (('za', 'r'), out)\nfor key in density_keys:\ninp = self._bds[key].values\ninp[np.where(np.isnan(inp))] = 0\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape, mode='nearest') / jacobian\nout[np.where(out &lt; 0)] = 0\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape)\ndata_vars[key] = (('za', 'r'), out)\n# end = perf_counter_ns()\n# print('Single_key conversion: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\n# dataset of (angle, alt_km) vars\niono = xarray.Dataset(data_vars=data_vars, coords={\n'za': nt, 'r': nr})\n# end = perf_counter_ns()\n# print('Single_key dataset: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nver = []\n# map all the wavelength data from (angle, alt_km, wavelength) -&gt; (la, r, wavelength)\nfor key in coord_wavelength:\ninp = bds['ver'].loc[dict(wavelength=key)].values\ninp[np.where(np.isnan(inp))] = 0\n# scaled by point distribution because flux is conserved, not brightness\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape, mode='nearest') * gd\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape, mode='nearest') / jacobian\nout[np.where(out &lt; 0)] = 0\n# inp[ttidx] = 0\n# inpsum = inp.sum()  # sum of input for valid angles\n# outpsum = out.sum()  # sum of output\n# out = out * (inpsum / outpsum)  # scale the sum to conserve total flux\nver.append(out.T)\n# end = perf_counter_ns()\n# print('VER eval: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nver = np.asarray(ver).T\nver = xr.DataArray(\nver,\ncoords={'za': nt, 'r': nr,\n'wavelength': coord_wavelength},\ndims=['za', 'r', 'wavelength'],\nname='ver'\n)  # create wl dataset\n# end = perf_counter_ns()\n# print('VER dataset: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nif self._wprodloss:\nd = {}\nfor key in state_keys:  # for each var with (angle, alt_km, state)\nres = []\ndef convert_state_stuff(st):\ninp = bds[key].loc[dict(state=st)].values\ninp[np.where(np.isnan(inp))] = 0\nout = geometric_transform(inp, mapping=self._global_from_local, output_shape=outp_shape)\nout[np.where(out &lt; 0)] = 0\nif key in ('production', 'excitedDensity'):\nout /= jacobian\n# out = warp(inp, inverse_map=(2, self._ntt, self._nrr), output_shape=outp_shape)\nreturn out.T\nres = list(map(convert_state_stuff, coord_state))\nres = np.asarray(res).T\nd[key] = (('za', 'r', 'state'), res)\n# end = perf_counter_ns()\n# print('Prod_Loss Eval: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\nprodloss = xarray.Dataset(\ndata_vars=d,\ncoords={'za': nt, 'r': nr, 'state': coord_state}\n)  # calculate (angle, alt_km, state) -&gt; (la, r, state) dataset\nelse:\nprodloss = xarray.Dataset()\n# end = perf_counter_ns()\n# print('Prod_Loss DS: %.3f us'%((end - start)*1e-3))\n## EGrid conversion (angle, energy) -&gt; (r, energy) ##\n# EGrid is avaliable really at (angle, alt_km = 0, energy)\n# So we get local coords for (angle, R=R0)\n# we discard the angle information because it is meaningless, EGrid is spatial\n# start = perf_counter_ns()\n_rr, _ = self.get_local_coords(\nbds.angle.values, np.ones(bds.angle.values.shape)*self._r0, r0=self._r0)\n_rr = rr[:, 0]  # spatial EGrid\nd = []\nfor en in coord_energy:  # for each energy\ninp = bds['precip'].loc[dict(energy=en)].values\n# interpolate to appropriate energy grid\nout = np.interp(nr, _rr, inp)\nd.append(out)\nd = np.asarray(d).T\nprecip = xarray.Dataset({'precip': (('r', 'energy'), d)}, coords={\n'r': nr, 'energy': coord_energy})\n# end = perf_counter_ns()\n# print('Precip interp and ds: %.3f us'%((end - start)*1e-3))\n# start = perf_counter_ns()\niono = xr.merge((iono, ver, prodloss, precip))  # merge all datasets\nbds_attr['altitude'] = {'values': self._r0 - EARTH_RADIUS, 'units': 'km',\n'description': 'Altitude of local polar coordinate origin ASL'}\niono.attrs.update(bds_attr)  # copy original attrs\n_ = list(map(lambda x: iono[x].attrs.update(bds[x].attrs), tuple(iono.data_vars.keys())))  # update attrs from bds\nunit_desc_dict = {\n'za': ('radians', 'Zenith angle'),\n'r': ('km', 'Radial distance in km')\n}\n_ = list(map(lambda x: iono[x].attrs.update(\n{'units': unit_desc_dict[x][0], 'description': unit_desc_dict[x][1]}), unit_desc_dict.keys()))\n# end = perf_counter_ns()\n# print('Merging: %.3f us'%((end - start)*1e-3))\nself._iono = iono\nreturn iono\n</code></pre>"}]}